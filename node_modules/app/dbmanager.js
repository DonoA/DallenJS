var mysql = require('mysql');
var Sequelize = require('sequelize');
var debug = require('debug')('DallenJS:server');
var fs = require('fs');

var ConnStr = JSON.parse(fs.readFileSync('config.json', 'utf8')).sqlConn;

var Channels = JSON.parse(fs.readFileSync('config.json', 'utf8')).twitchChannels;

var sequelize = new Sequelize(
  ConnStr.database,
  ConnStr.user,
  ConnStr.password,
  {
    logging: console.log,
    host: ConnStr.host
  }
);

var User = sequelize.define('users', {
    email: {
        type: Sequelize.STRING
    },
    name: {
        type: Sequelize.STRING
    },
    icon: {
      type: Sequelize.STRING
    },
    admin: {
      type: Sequelize.BOOLEAN,
      defaultValue: false
    }
}, {
    freezeTableName: true,
    paranoid: false
});

var Project = sequelize.define('projects', {
    name: {
        type: Sequelize.STRING
    },
    type: {
        type: Sequelize.STRING
    },
    repo: {
        type: Sequelize.STRING
    },
    description: {
        type: Sequelize.TEXT
    },
    readme: {
        type: Sequelize.STRING
    }
}, {
    freezeTableName: true,
    paranoid: false
});

var Archive = sequelize.define('archives', {
    name: {
        type: Sequelize.STRING
    },
    description: {
        type: Sequelize.TEXT
    }
}, {
    freezeTableName: true,
    paranoid: false
});

var Download = sequelize.define('downloads', {
    name: {
        type: Sequelize.STRING
    },
    url: {
        type: Sequelize.TEXT
    }
}, {
    freezeTableName: true,
    paranoid: false
});

Archive.hasMany(Download);
Download.belongsTo(Archive);

var ImageType = sequelize.define('images', {
    description: {
        type: Sequelize.STRING
    },
    url: {
        type: Sequelize.STRING
    }
}, {
    freezeTableName: true,
    paranoid: false
});

var MapType = sequelize.define('maps', {
    name: {
        type: Sequelize.STRING
    }
}, {
    freezeTableName: true,
    paranoid: false
});

var streams = {};

Channels.forEach( k => {
  streams[k] = sequelize.define('stream_' + k, {
      user: {
          type: Sequelize.STRING
      },
      chat: {
          type: Sequelize.TEXT
      }
    }, {
        freezeTableName: true,
        paranoid: false
    });
});

var prjtypCache;

function init(){
  sequelize.sync();
};

function getTwitchStats(channel, callback){
  var q = "show table status from dallenjs where name = '" + channel+"'";
  sequelize.query(q, { type: sequelize.QueryTypes.SHOW}).then(rows => {
    callback({rows: rows[0].Rows,
            avg_rows: rows[0].Avg_row_length,
            data: rows[0].Data_length,
            AI: rows[0].Auto_increment});
  });
}

module.exports = {
  init: init,
  sequelize: sequelize,
  users: User,
  projects: Project,
  archives: Archive,
  downloads: Download,
  images: ImageType,
  maps: MapType,
  streams: streams,
  getTwitchStats: getTwitchStats,
  prjtypCache: prjtypCache
};

/*

},
pullDB: function(){
    var failed = false;
    GLOBAL.plugins={mcme: [], bukkit: []};
    GLOBAL.games=[];
    //load plugins for mcme and bukkit
    var q = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '"+GLOBAL.ConnStr.database+"' AND  TABLE_NAME = 'plugins'";
    dbconnection.query(q, function(err, rows) {
        if(!err&&rows.length==0){
            q = "CREATE TABLE plugins "+
                "(pluginID int AUTO_INCREMENT, name varchar(30), repo varchar(30), version varchar(30), download varchar(30), type varchar(10),"+
                "PRIMARY KEY (pluginID)) CHARSET=utf8";
            dbconnection.query(q, function(err, rows) {console.log("Created Table for plugins"); if(err){failed = true;};});
        }else{
            q = "SELECT * FROM plugins WHERE type='bukkit'";
            dbconnection.query(q, function(err, rows) {
                if(err){
                    console.log(q);
                    console.error(err.stack);
                    failed = true;
                }else{
                    rows.forEach(function (i, e){
                        GLOBAL.plugins.bukkit.push(
                            {name: rows[e].name,
                             repo: rows[e].repo,
                             version: rows[e].version,
                             download: rows[e].download});
                    });
                }
            });
            q = "SELECT * FROM plugins WHERE type='mcme'";
            dbconnection.query(q, function(err, rows) {
                if(err){
                    console.log(q);
                    console.error(err.stack);
                    failed = true;
                }else{
                    rows.forEach(function (i, e){
                        GLOBAL.plugins.mcme.push({
                            name: rows[e].name,
                            repo: rows[e].repo,
                            version: rows[e].version,
                            download: rows[e].download});
                    });
                }
            });
        }
    });

    //load games from DB
    var q = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '"+GLOBAL.ConnStr.database+"' AND  TABLE_NAME = 'games'";
    dbconnection.query(q, function(err, rows){
        if(!err&&rows.length==0){
            q = "CREATE TABLE games "+
                "(gameID int AUTO_INCREMENT, name varchar(30), path varchar(30), version varchar(30), blurb text, "+
                "PRIMARY KEY (gameID)) CHARSET=utf8";
            dbconnection.query(q, function(err, rows) {console.log("Created Table for games"); if(err){debug(err.stack); failed = true;}});
        }else{
            q = "SELECT * FROM games";
            dbconnection.query(q, function(err, rows){
                if(err){
                    debug(err.stack);
                    failed = true;
                }else{
                    rows.forEach(function (i, e){
                        GLOBAL.games.push(
                            {name: rows[e].name.replace(new RegExp(' ', 'g'), '-'),
                             path: rows[e].path,
                             extension: rows[e].extension,
                             version: rows[e].version,
                             blurb: rows[e].blurb});
                    });
                }
            });
        }
    });
    if(!failed){
        console.log("pulled DB!");
        return "pulled DB!";
    }else{
        console.error("Failed to pull DB!");
        return "Failed to pull DB!";
    }

},
CreateDB: function(){
  var q = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '"+GLOBAL.ConnStr.database+"'";
  var dat = fs.readFileSync('data/data.sql', 'utf8');
  dbconnection.query(q, function(err, rows){
    if(rows.indexOf("games") > -1 && rows.indexOf("plugins") > -1 && rows.indexOf("users") > -1){
      return;
    }else{
      dbconnection.query(dat, function(err, rows){
        if(!err){
          console.log("Loaded data.sql");
          console.log(rows);
        }
      });
    }
  });
}
*/
